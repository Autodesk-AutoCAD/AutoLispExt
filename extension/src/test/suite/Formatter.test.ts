import * as chai from 'chai';
import * as fs from 'fs'
import * as path from 'path';
import { beforeEach, afterEach } from 'mocha';
import { LispFormatter } from '../../format/formatter';
import { ReadonlyDocument } from '../../project/readOnlyDocument';
import { longListFormatAsWideStyleSingleCol, resetLongListFormatAsSingleColum } from '../../format/sexpression';
import { setMaxLineChars, resetMaxLineChars } from '../../format/sexpression';
import { setIndentSpaces, resetIndentSpaces } from '../../format/sexpression';
import { setClosedParenInSameLine, resetClosedParenInSameLine } from '../../format/sexpression';
import { longListFormatAsFitMargin } from '../../format/sexpression';

let assert = chai.assert;
let testDir = path.join(__dirname + "/../../../extension/src/test");
const outputDir = path.join(testDir + "/OutputFile");
fs.mkdir(outputDir, { recursive: true }, (err) => {
	if (err) {
		return console.error(err);
	}
});
function getFileName(i: number) {
	const source = path.join(testDir + "/SourceFile/unFormatted" + i + ".lsp");
	const output = path.join(testDir + "/OutputFile/formatedOutputFile" + i + ".lsp");
	const baseline = path.join(testDir + "/Baseline/formatedBasefile" + i + ".lsp");
	return [source, output,baseline];
}
function comparefileSync(i : number, output : string,fmt : string, baseline : string) {
	try {
		fs.writeFileSync(output,fmt);
		let baseString = fs.readFileSync(baseline, { encoding: 'utf8', flag: 'r' });
		//Trick to pass the test is to ignore the \r 
		fmt = fmt.replace(/(\r)/gm, "");
		baseString = baseString.replace(/(\r)/gm, "");
		assert.isTrue(fmt === baseString);
	} catch (err) {
		assert.fail(`Format Test Case ${i} failed!`);
	}
}

suite("Lisp Formatter Tests", function () {
	// Notes:
	// Format test is a setting sensitive which depends on the format settings defined 
	// in the fmtconfig.ts
	// The baseline is generated by the above default value:
	// MaxLineChars: 85
	// NarrowStyleIndent: 2
	// CloseParenthesisStyle: 'New line with outer indentation'
	// LongListFormatStyle: 'Fill to margin'
	// Need to remove the \r to do the format output compare
	beforeEach(() => {
		//Set the default value to run the test
		//After call these setXXX() formatting will not 
		//Get setting value from vscode, instead it will receive
		//value from the test cases
		setClosedParenInSameLine(false);
		setIndentSpaces(2);
		setMaxLineChars(85);
		longListFormatAsFitMargin();
	});

	afterEach(() => {
		//Restore the default states
		resetClosedParenInSameLine();
		resetIndentSpaces();
		resetMaxLineChars();
		resetLongListFormatAsSingleColum();
	});

	test("Lisp Formatter Test case 1", function () {
		//Basic test case
		let i = 1;
		try {
			const [source, output, baseline] = getFileName(i);
			const doc = ReadonlyDocument.open(source);
			let fmt = LispFormatter.format(doc, null);
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 2", function () {
		// Test setq in new lines
		let i = 2;
		try {
			const [source, output, baseline] = getFileName(i);
			const doc = ReadonlyDocument.open(source);
			let fmt = LispFormatter.format(doc, null);
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 3", function () {
		// Test multiple function format
		let i = 3;
		try {
			const [source, output, baseline] = getFileName(i);
			const doc = ReadonlyDocument.open(source);
			let fmt = LispFormatter.format(doc, null);
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 4", function () {
		// The empty line should not be removed after format
		let i = 4;
		try {
			const [source, output, baseline] = getFileName(i);
			const doc = ReadonlyDocument.open(source);
			let fmt = LispFormatter.format(doc, null);
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 5", function () {
		// Test the Max line chars setting
		// Test the bug that it will be a space between the last two brackets ) )
		let i = 5;
		try {
			const [source, output, baseline] = getFileName(i);
			const doc = ReadonlyDocument.open(source);
			setMaxLineChars(65);
			let fmt = LispFormatter.format(doc, null);
			resetMaxLineChars();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 6", function () {
		// Test the indent, the default indent should be 2
		let i = 6;
		try {
			const [source, output, baseline] = getFileName(i);
			const doc = ReadonlyDocument.open(source);
			let fmt = LispFormatter.format(doc, null);
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 7", function () {
		// Test the single column setting
		let i = 7;
		try {
			const [source, output, baseline] = getFileName(i);
			const doc = ReadonlyDocument.open(source);
			// set as wide single column format
			longListFormatAsWideStyleSingleCol();
			let fmt = LispFormatter.format(doc, null);
			// set back as kFitToMargin format
			resetLongListFormatAsSingleColum();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 8", function () {
		// Test another single column setting
		let i = 8;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			// set as wide single column format
			longListFormatAsWideStyleSingleCol();
			let fmt = LispFormatter.format(doc, null);
			resetLongListFormatAsSingleColum();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 9", function () {
		// Test list format which comes from an old bug
		// This is a bug needs to be fixed in lisp extension
		let i = 9;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			let fmt = LispFormatter.format(doc, null);
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 10", function () {
		// Test long list and big file - chinaMap.lsp
		// This test will take long time
		let i = 10;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			let fmt = LispFormatter.format(doc, null);
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 11", function () {
		// Test indent space setting
		let i = 11;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			setIndentSpaces(4);
			let fmt = LispFormatter.format(doc, null);
			resetIndentSpaces();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 12", function () {
		// Test Closed Parenthesis In Same Line setting
		let i = 12;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			setClosedParenInSameLine(true);
			let fmt = LispFormatter.format(doc, null);
			resetClosedParenInSameLine();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 13", function () {
		// Test Mixed settings
		// setClosedParenInSameLine(true);
		// setIndentSpaces(4);
		// setMaxLineChars(65);
		// longListFormatAsWideStyleSingleCol();
		let i = 13;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			setClosedParenInSameLine(true);
			setIndentSpaces(4);
			setMaxLineChars(65);
			longListFormatAsWideStyleSingleCol();
			let fmt = LispFormatter.format(doc, null);
			resetClosedParenInSameLine();
			resetIndentSpaces();
			resetLongListFormatAsSingleColum();
			resetMaxLineChars();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 14", function () {
		// Test the comments after the brackets ") ;progn"
		// setIndentSpaces(4);
		// setMaxLineChars(80);
		let i = 14;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			setIndentSpaces(4);
			setMaxLineChars(80);
			let fmt = LispFormatter.format(doc, null);
			resetIndentSpaces();
			resetMaxLineChars();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 15", function () {
		// Test unicode
		// setIndentSpaces(2);
		// setMaxLineChars(60);
		let i = 15;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			setIndentSpaces(2);
			setMaxLineChars(60);
			let fmt = LispFormatter.format(doc, null);
			resetIndentSpaces();
			resetMaxLineChars();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 16", function () {
		// Test invalid setting
		// setIndentSpaces(8);
		// setMaxLineChars(30);
		let i = 16;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			setIndentSpaces(8);
			setMaxLineChars(30);
			let fmt = LispFormatter.format(doc, null);
			resetIndentSpaces();
			resetMaxLineChars();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

});
