import * as chai from 'chai';
import * as fs from 'fs'
import * as path from 'path';
import * as vscode from 'vscode';
import { before, beforeEach, afterEach } from 'mocha';
import { LispFormatter } from '../../format/formatter';
import { ReadonlyDocument } from '../../project/readOnlyDocument';
// import { longListFormatAsWideStyleSingleCol, resetLongListFormatAsSingleColum } from '../../format/sexpression';
// import { setMaxLineChars, resetMaxLineChars } from '../../format/sexpression';
// import { setIndentSpaces, resetIndentSpaces } from '../../format/sexpression';
// import { setClosedParenInSameLine, resetClosedParenInSameLine } from '../../format/sexpression';
// import { longListFormatAsFitMargin } from '../../format/sexpression';
// import * as sinon from 'sinon';

let assert = chai.assert;

let testDir = path.join(__dirname + "/../../../extension/src/test");
const outputDir = path.join(testDir + "/OutputFile");

let config = vscode.workspace.getConfiguration();

async function  restoreConfig() {
 	await config.update('format.CloseParenthesisStyle','New line with outer identation',vscode.ConfigurationTarget.Global);
 	await config.update('format.MaxLineChars',85,vscode.ConfigurationTarget.Global);
 	await config.update('format.LongListFormatStyle','Fill to Margin',vscode.ConfigurationTarget.Global);
 	await config.update('format.NarrowStyleIndent',2,vscode.ConfigurationTarget.Global);
}

async function setClosedParenInSameLine(sameline : string){
	await config.update('format.CloseParenthesisStyle',sameline,vscode.ConfigurationTarget.Global)
	.then(() =>{
		console.log(`config is updated ${config.get('format.CloseParenthesisStyle')}`);

	});
}
async function setMaxLineChars(maxchar : number){
	await config.update('format.MaxLineChars',maxchar,vscode.ConfigurationTarget.Global)
	.then(() =>{
		console.log(`config is updated ${config.get('format.MaxLineChars')}`);
	});
}
async function setLongListFormat(singleCol : string){
	await config.update('format.LongListFormatStyle',singleCol,vscode.ConfigurationTarget.Global)
	.then(() =>{
		console.log(`config is updated ${config.get('format.LongListFormatStyle')}`);
	});
}
async function setIndentSpaces(indent : number){
	await config.update('format.NarrowStyleIndent',indent,vscode.ConfigurationTarget.Global)
	.then(() =>{
		console.log(`config is updated ${config.get('format.NarrowStyleIndent')}`);
	});
}

fs.mkdir(outputDir, { recursive: true }, (err) => {
	if (err) {
		return console.error(err);
	}
});

function getFileName(i: number) {
	const source = path.join(testDir + "/SourceFile/unFormatted" + i + ".lsp");
	const output = path.join(testDir + "/OutputFile/formatedOutputFile" + i + ".lsp");
	const baseline = path.join(testDir + "/Baseline/formatedBasefile" + i + ".lsp");
	return [source, output,baseline];
}
function comparefileSync(i : number, output : string,fmt : string, baseline : string) {
	try {
		fs.writeFileSync(output,fmt);
		let baseString = fs.readFileSync(baseline, { encoding: 'utf8', flag: 'r' });
		//Trick to pass the test is to ignore the \r 
		fmt = fmt.replace(/(\r)/gm, "");
		baseString = baseString.replace(/(\r)/gm, "");
		assert.isTrue(fmt === baseString);
	} catch (err) {
		assert.fail(`Format Test Case ${i} failed!`);
	}
}

suite.only("Lisp Formatter Sinon Tests", function () {
	// Notes:
	// Format test is a setting sensitive which depends on the format settings defined 
	// in the fmtconfig.ts
	// The baseline is generated by the above default value:
	// MaxLineChars: 85
	// NarrowStyleIndent: 2
	// CloseParenthesisStyle: 'New line with outer indentation'
	// LongListFormatStyle: 'Fill to margin'
	// Need to remove the \r to do the format output compare
	before(()=>{
		config = vscode.workspace.getConfiguration('autolispext');
	})

	beforeEach(async () => {
		//Set the default value to run the test
		//After call these setXXX() formatting will not 
		//Get setting value from vscode, instead it will receive
		//value from the test cases

		// setClosedParenInSameLine(false);
		// setIndentSpaces(2);
		// setMaxLineChars(85);
		// longListFormatAsFitMargin();
		// config = vscode.workspace.getConfiguration('autolispext');
		await restoreConfig();
	});

	afterEach(async () => {
		// await restoreConfig();

		//Restore the default states
		// resetClosedParenInSameLine();
		// resetIndentSpaces();
		// resetMaxLineChars();
		// resetLongListFormatAsSingleColum();
	});

	test("Lisp Formatter Test case 1", function () {
		//Basic test case
		let i = 1;
		try {
			const [source, output, baseline] = getFileName(i);
			const doc = ReadonlyDocument.open(source);
			let fmt = LispFormatter.format(doc, null);
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 2", function () {
		// Test setq in new lines
		let i = 2;
		try {
			const [source, output, baseline] = getFileName(i);
			const doc = ReadonlyDocument.open(source);
			let fmt = LispFormatter.format(doc, null);
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 3", function () {
		// Test multiple function format
		let i = 3;
		try {
			const [source, output, baseline] = getFileName(i);
			const doc = ReadonlyDocument.open(source);
			let fmt = LispFormatter.format(doc, null);
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 4", function () {
		// The empty line should not be removed after format
		let i = 4;
		try {
			const [source, output, baseline] = getFileName(i);
			const doc = ReadonlyDocument.open(source);
			let fmt = LispFormatter.format(doc, null);
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 5", async function () {
		// Test the Max line chars setting
		// Test the bug that it will be a space between the last two brackets ) )
		let i = 5;
		// console.log(`config is ${config.get('format.CloseParenthesisStyle').toString()} in ${i}`);
		try {
			const [source, output, baseline] = getFileName(i);
			const doc = ReadonlyDocument.open(source);
			await setMaxLineChars(65);
			let fmt = LispFormatter.format(doc, null);
			// resetMaxLineChars();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 6", function () {
		// Test the indent, the default indent should be 2
		let i = 6;
		try {
			const [source, output, baseline] = getFileName(i);
			const doc = ReadonlyDocument.open(source);
			let fmt = LispFormatter.format(doc, null);
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 7", async function () {
		// Test the single column setting
		let i = 7;
		// console.log(`config is ${config.get('format.LongListFormatStyle').toString()} in ${i}`);

		try {
			const [source, output, baseline] = getFileName(i);
			const doc = ReadonlyDocument.open(source);
			// set as wide single column format
			// longListFormatAsWideStyleSingleCol();
			await setLongListFormat('Single Column');
			let fmt = LispFormatter.format(doc, null);
			// set back as kFitToMargin format
			// resetLongListFormatAsSingleColum();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 8",async function () {
		// Test another single column setting
		let i = 8;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			// set as wide single column format
			// longListFormatAsWideStyleSingleCol();
			await setLongListFormat('Single Column');

			let fmt = LispFormatter.format(doc, null);
			// resetLongListFormatAsSingleColum();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 9", function () {
		// Test list format which comes from an old bug
		// This is a bug needs to be fixed in lisp extension
		let i = 9;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			let fmt = LispFormatter.format(doc, null);
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 10", function () {
		// Test long list and big file - chinaMap.lsp
		// This test will take long time
		let i = 10;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			let fmt = LispFormatter.format(doc, null);
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 11",async function () {
		// Test indent space setting
		let i = 11;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			await setIndentSpaces(4);
			let fmt = LispFormatter.format(doc, null);
			// resetIndentSpaces();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 12",async function () {
		// Test Closed Parenthesis In Same Line setting
		let i = 12;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			// setClosedParenInSameLine(true);
			await setClosedParenInSameLine('same line');
			let fmt = LispFormatter.format(doc, null);
			// resetClosedParenInSameLine();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 13",async function () {
		// Test Mixed settings
		// setClosedParenInSameLine(true);
		// setIndentSpaces(4);
		// setMaxLineChars(65);
		// longListFormatAsWideStyleSingleCol();
		let i = 13;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			await setClosedParenInSameLine('same line');
			await setIndentSpaces(4);
			await setMaxLineChars(65);
			await setLongListFormat('single column');
			// longListFormatAsWideStyleSingleCol();
			let fmt = LispFormatter.format(doc, null);
			// resetClosedParenInSameLine();
			// resetIndentSpaces();
			// resetLongListFormatAsSingleColum();
			// resetMaxLineChars();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 14",async function () {
		// Test the comments after the brackets ") ;progn"
		// setIndentSpaces(4);
		// setMaxLineChars(80);
		let i = 14;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			await setIndentSpaces(4);
			await setMaxLineChars(80);
			let fmt = LispFormatter.format(doc, null);
			// resetIndentSpaces();
			// resetMaxLineChars();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 15",async function () {
		// Test unicode
		// setIndentSpaces(2);
		// setMaxLineChars(60);
		let i = 15;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			await setIndentSpaces(2);
			await setMaxLineChars(60);
			let fmt = LispFormatter.format(doc, null);
			// resetIndentSpaces();
			// resetMaxLineChars();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

	test("Lisp Formatter Test case 16",async function () {
		// Test invalid setting
		// setIndentSpaces(8);
		// setMaxLineChars(30);
		let i = 16;
		try {
			const [source, output, baseline] = getFileName(i);
			let doc = ReadonlyDocument.open(source);
			await setIndentSpaces(8);
			await setMaxLineChars(30);
			let fmt = LispFormatter.format(doc, null);
			// resetIndentSpaces();
			// resetMaxLineChars();
			comparefileSync(i,output,fmt,baseline);
		}
		catch (err) {
			assert.fail(`The lisp format test case ${i} failed`);
		}
	});

});
